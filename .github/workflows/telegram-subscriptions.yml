name: Manage Telegram Subscriptions

on:
  schedule:
    # Runs once daily at 7:00 AM PST (15:00 UTC) - 30 min before song goes out
    # Note: Adjust to 14:00 UTC during PDT (spring/summer)
    - cron: '0 15 * * *'
  workflow_dispatch: # Allows manual trigger

jobs:
  manage-subscriptions:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Process subscription requests
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        run: |
          node << 'EOF'
          const https = require('https');
          const fs = require('fs');
          
          const botToken = process.env.TELEGRAM_BOT_TOKEN;
          const subscribersFile = '_data/telegram_subscribers.json';
          
          // Load existing subscribers or create empty list
          let subscribers = { users: [] };
          if (fs.existsSync(subscribersFile)) {
            subscribers = JSON.parse(fs.readFileSync(subscribersFile, 'utf8'));
          }
          
          // Function to make HTTPS requests
          function makeRequest(options) {
            return new Promise((resolve, reject) => {
              https.get(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  try {
                    resolve(JSON.parse(data));
                  } catch (e) {
                    reject(new Error('Failed to parse response: ' + data));
                  }
                });
              }).on('error', reject);
            });
          }
          
          // Function to send message
          function sendMessage(chatId, text) {
            return new Promise((resolve, reject) => {
              const postData = JSON.stringify({
                chat_id: chatId,
                text: text,
                parse_mode: 'HTML'
              });
              
              const options = {
                hostname: 'api.telegram.org',
                path: `/bot${botToken}/sendMessage`,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    if (response.ok) {
                      resolve(response);
                    } else {
                      console.error('Telegram API error:', response);
                      resolve(response); // Don't reject to avoid stopping workflow
                    }
                  } catch (e) {
                    console.error('Failed to parse Telegram response:', data);
                    resolve(); // Don't reject
                  }
                });
              });
              
              req.on('error', (error) => {
                console.error('Request error:', error);
                resolve(); // Don't reject
              });
              
              req.write(postData);
              req.end();
            });
          }
          
          // Get updates from Telegram
          async function processUpdates() {
            const options = {
              hostname: 'api.telegram.org',
              path: `/bot${botToken}/getUpdates`
            };
            
            const response = await makeRequest(options);
            
            if (!response.ok || !response.result.length) {
              console.log('No new messages');
              return false;
            }
            
            let hasChanges = false;
            let lastUpdateId = 0;
            
            for (const update of response.result) {
              lastUpdateId = Math.max(lastUpdateId, update.update_id);
              
              if (!update.message || !update.message.text) continue;
              
              const chatId = update.message.chat.id;
              const text = update.message.text.toLowerCase().trim();
              const username = update.message.from.username || update.message.from.first_name;
              
              if (text === '/subscribe' || text === '/start') {
                // Check if already subscribed
                const existingUser = subscribers.users.find(u => u.chat_id === chatId);
                
                if (existingUser) {
                  await sendMessage(chatId, 'âœ… You\'re already subscribed to the daily song, Silly!');
                } else {
                  subscribers.users.push({
                    chat_id: chatId,
                    username: username,
                    subscribed_at: new Date().toISOString()
                  });
                  hasChanges = true;
                  await sendMessage(chatId, 'ðŸ™Œ <b>Subscribed!</b> Now just sit and wait until ~07:45 PT for your first song to arrive.\n\n/unsubscribe - Stop receiving songs');
                  console.log(`New subscriber: ${username} (${chatId})`);
                }
              } else if (text === '/unsubscribe') {
                const index = subscribers.users.findIndex(u => u.chat_id === chatId);
                
                if (index !== -1) {
                  subscribers.users.splice(index, 1);
                  hasChanges = true;
                  await sendMessage(chatId, 'ðŸ‘‹ <b>Unsubscribed</b>. Send /subscribe anytime to rejoin!');
                  console.log(`Unsubscribed: ${username} (${chatId})`);
                } else {
                  await sendMessage(chatId, 'You\'re not currently subscribed. Send /subscribe to start receiving daily songs!');
                }
              } else if (text === '/help') {
                await sendMessage(chatId, 'ðŸ›Ÿ <b>Help</b>\n\nCommands:\n/subscribe - Get your daily song (~07:45 PT)\n/unsubscribe - Stop receiving songs\n/help - Show this message');
              }
            }
            
            // Mark messages as read
            if (lastUpdateId > 0) {
              const offsetOptions = {
                hostname: 'api.telegram.org',
                path: `/bot${botToken}/getUpdates?offset=${lastUpdateId + 1}`
              };
              await makeRequest(offsetOptions);
            }
            
            return hasChanges;
          }
          
          // Main execution
          (async () => {
            try {
              const hasChanges = await processUpdates();
              
              if (hasChanges) {
                // Create _data directory if it doesn't exist
                if (!fs.existsSync('_data')) {
                  fs.mkdirSync('_data');
                }
                
                // Save updated subscribers
                fs.writeFileSync(subscribersFile, JSON.stringify(subscribers, null, 2));
                console.log(`Subscribers updated. Total: ${subscribers.users.length}`);
              } else {
                console.log('No subscription changes');
              }
            } catch (error) {
              console.error('Error:', error.message);
              process.exit(1);
            }
          })();
          EOF
      
      - name: Commit subscriber changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add _data/telegram_subscribers.json
          git diff --quiet && git diff --staged --quiet || (git commit -m "Update Telegram subscribers" && git push)
